component qdtoolchange "EMC HAL component to manage Data Summit Quickdraw tool changer";

pin in bit toolchange_req "Request from M6 that a tool change is required. Normally comes from iocontrol.0.tool-change";
pin in signed new_tool_no "The number of the desired new tool. Range is 0 to parameter turret_capacity. Normally wired to iocontrol.n.tool-prep-number";
pin in bit qd_complete "Reset signal from the Quickdraw Tool Changer that the current operation is complete";
pin in bit machine_on "Tell this component that a the machine is on. Normally wired to halui.machine.is-on. Used to reset error conditions";
pin in bit qd_auto "Indication that the tool changer is in auto mode. Connected to pin 9 (+12V) of the tool changer interface connector";

pin out bit tool_in_output "Tool-In command to the tool changer. Moves the arm to the spindle";
pin out bit tool_out_output "Tool-Out command to the tool changer. Moves the arm to the carousel";
pin out bit carousel_cw_output "Turret CW command to the tool changer. Moves the carousel clockwise";
pin out bit carousel_ccw_output "Turret CCW command to the tool changer. Moves the carousel counterclockwise";
pin out bit carousel_home_output "Turret Home command to the tool changer.";
pin out bit change_ack "True when the a tool change is complete. Normally this is connected to iocontrol.0.tool-prepared";

pin out unsigned error_mask
"""When an error occurs, bits in this output pin indicate what the error is:
	0 -- No Error
	1 -- Invalid new_tool_no input
	4 -- Spindle-to-Carousel Arm Movement Timed Out
	8 -- Carousel-to-Spindle Arm Movement Timed Out
   16 -- qd_complete Input Stuck Low
   32 -- qd_complete Input Stuck High
   64 -- Carousel Movement Timed Out
  128 -- Carousel Home Operation Timed Out
""";
pin out unsigned current_state "For debugging. State of the internal state machine";
pin out unsigned current_tool "For debugging. Tool number currently in position. Will be zero until homed";

param rw float carousel_home_timeout=45.0 "Maximum time in seconds to allow the carousel to home. Default = 45 sec";
param rw float carousel_move_timeout=3.0 "Maximum time in seconds to allow the carousel to move one tool position. Default = 3.0 sec";
param rw float arm_move_timeout=15.0 "Maximum time in seconds to allow for moving a tool from the carousel to or from the spindle. Default = 15 sec";
param rw float complete_max_time=1.0 "Maximum time in seconds to allow the complete input to remain high before flagging an error. Default = 1.0 sec";
param rw unsigned changer_capacity=24 "Max number of tools the tool changer is capable of handling. Default = 24";
param rw float debounce_period=0.04 "Time in seconds to allow the complete input pin to settle. Default = 0.040 sec";

variable short cur_state;
variable short prev_state;
variable short next_state;
variable bool state_changed;
variable float timer;
variable float deb_accum;
variable float auto_accum;
variable bool completed; // Debounced state of the complete input pin
variable int new_tool_in;
variable int movement_cnt; // How far and which direction to move the carousel.
variable int move_cw; // Move the carousel CW
variable bool homed_flag = FALSE; // Whether the tool changer carousel has been homed.
variable bool is_on; // Current state of machine_on
variable int cur_pocket_no; // The tool pocket currently in position. 0 if not homed
variable int error_outputs; // ORed error conditions
variable bool ack_out;
variable int state_index = 0;
variable int state_stack[10];
variable int STATE_STACK_DEPTH = 10;

description """
	qdtoolchange manages the Dana Summit Quickdraw tool changer.o

	The Quickdraw tool changer hardware has five command inputs and one output
		(RESET). The RESET output is a relay whose contacts close when the
		previously-commanded operation is completed. The five hardware command
		inputs are TURRET CW, TURRET CCW, TURRET HOME, TOOL IN, and TOOL OUT. In
		addition, this component requires a connection to the +12V on the
		M-POSITITION connector, and the GROUND pin on J7. This pair is used to
		determine whether the tool changer front panel has been switched away from
		the AUTO position. If this happens, this component assumes the operator may
		have moved the carousel and so deems the hardware unhomed, which will
		require a homing operation before any tools can be used.
	
	When this component gets a tool change request from iocontrol, it evaluates
		the homed status and the new tool number. If the tool changer is not homed,
		the changer will be homed first. If there is a tool in the spindle it will
		be returned to the carousel at its current location, then the carousel
		homed if needed, then the carousel will be moved to the new tool, and that
		tool moved to the spindle.

	Note that since the Quickdraw tool changer cannot prepare a tool before it
		is needed, there must be a hal loopback connection between the prepare tool
		request and the tool_prepared answer, like this: net tool-prepare-loopback
		iocontrol.0.tool-prepare => iocontrol.0.tool-prepared

	The operation of this component is as a state machine. It has 8 states, described here:
	0. STATE_IDLE -- Does nothing except to monitor for a new tool request.
	1. STATE_WAIT_COMPL_FALSE -- Waits for the debounced complete input has gone FALSE. If the time 
		exceeds complete_max_time, issues an error.
	2. STATE_INIT -- Entered when a new tool request is received. Does the following:
		a. Check that the carousel has been homed. If not, home it now.
		b. Check whether the new requested tool and the previous tool are the same. If so sets complete and 
			returns to idle.
		c. Check that the complete input pin is FALSE. If not, wait for it but not longer than complete_max_time
		d. Determines how far and in which direction to move the carousel to the next desired tool.
		e. Sets the CHANGING output to TRUE.
		f. Starts the main timer.
		g. Sets the next state, which depends on the input pins.
	3. STATE_TOOL_OUT -- Issues a TOOL_OUT command to the hardware and waits for completion or timeout.
	4. STATE_TOOL_IN -- Issues a TOOL_IN command to the hardware and waits for completion or timeout.
	5. STATE_CAROUSEL_MOVE -- Issues carousel_cw_output or carousel_ccw_output commands to the hardare.
		Counts complete pulses to determine when the new tool is in the active position.
	6. STATE_CAROUSEL_HOME -- Issues a carousel_home_output command to the hardware and waits for completion or timeout.
	7. STATE_ERROR -- Entered if an error occurs. Changes to STATE_IDLE when machine is turned from off to on.
""";

license "GPL";
author "K. Cunningham";
option singleton yes;
option extra_setup yes;
function _;
;;

// Codes for error_mask for each error
#define ERROR_INVALID_NEW_TOOL 1
#define ERROR_INVALID_CUR_TOOL 2
#define ERROR_ARM_TO_CAROUSEL_FAIL 4
#define ERROR_ARM_TO_SPINDLE_FAIL 8
#define ERROR_QD_COMPLETE_STUCK_LOW 0x10
#define ERROR_QD_COMPLETE_STUCK_HIGH 0x20
#define ERROR_CAROUSEL_MOVE_FAIL 0x40
#define ERROR_CAROUSEL_HOME_FAIL 0x80
#define ERROR_NOT_AUTO_MODE 0x100


// State names defined
typedef enum {
	STATE_IDLE = 0,
	STATE_WAIT_COMPL_FALSE,
	STATE_INIT,
	STATE_TOOL_OUT,
	STATE_TOOL_IN,
	STATE_CAROUSEL_MOVE,
	STATE_CAROUSEL_HOME,
	STATE_ERROR
} States;

bool was_completed;
bool was_on; // Previous state of pgm_running
int distance;

void enqueue_state(int state) {
	/* Pushes a new state on our stack. If the stack is full, does nothing */
	if(++state_index >= STATE_STACK_DEPTH) {
		state_index = STATE_STACK_DEPTH - 1;
	} else {
		state_stack[state_index] = state;
	}
}

int dequeue_state(void) {
	/* Pops the next state from the state stack. the bottom state is 
	 *  always STATE_IDLE.
	 */
	if(--state_index < 0) {
		state_index = 0;
		return STATE_IDLE;
	} else {
		return state_stack[state_index];
	}
}

FUNCTION(_) {
	/* Debounce the qd_complete and the qd_auto input pins. If (completed !=
	 * was_completed) the state has changed this cycle.  Debounce is done by
	 * adding elapsed time to an accumulator while the bit is TRUE and
	 * subtracting elapsed time while the bit is FALSE. The accumulator is
	 * limited between 0 and debounce_period. If the accumulator reaches
	 * debounce_period, the bit is deemed TRUE. If it reaches 0, the bit is
	 * deemed FALSE. */
	timer += fperiod;	
	was_completed = completed;
	if(qd_complete) {
		deb_accum += fperiod;
		if(deb_accum > debounce_period) {
			deb_accum = debounce_period;
			completed = TRUE;
		}
	} else {
		deb_accum -= fperiod;
		if(deb_accum < 0.0) {
			deb_accum = 0.0;
			completed = FALSE;
		}
	}
	if(qd_auto) {
		auto_accum += fperiod;
		if(auto_accum > debounce_period) {
			auto_accum = debounce_period;
		}
	} else {
		// If the debounced state of qd_auto is FALSE, unhome the tool changer.
		auto_accum -= fperiod;
		if(auto_accum < 0.0) {
			auto_accum = 0.0;
			homed_flag = FALSE;
		}
	}

	/* Maintain the past and current machine states. */
	was_on = is_on;
	is_on = machine_on;
			
	state_changed = (cur_state != prev_state);
	if(state_changed) {
		prev_state = cur_state;
	} 

	/* On entering each state other than IDLE, check for AUTO mode. If not, it's an error. */
	switch(cur_state) {
		case STATE_IDLE: // Check toolchange_req for a new tool request.
			if(state_changed) {
				/* We've returned here from another state. Set ack_out */
				ack_out = TRUE;
			} else if(toolchange_req && !ack_out) {
				/* Latch the tool number inputs. */
				new_tool_in = new_tool_no;
				if(new_tool_in < 0 || new_tool_in > changer_capacity) {
					rtapi_print_msg(RTAPI_MSG_ERR, "Invalid new_tool_no passed to qdtoolchange");
					error_outputs = ERROR_INVALID_NEW_TOOL;
					cur_state = STATE_ERROR;
				} else {
					/* All OK. Continue */
					cur_state = STATE_INIT;
				}
			} else if(!toolchange_req) {
				/* Release the ack only when the toolchange_req goes FALSE. */
				ack_out = FALSE;
			}
			break; // STATE_IDLE

		case STATE_INIT:
			/* Check state of hardware and take action if needed. Otherwise, start the tool change.
			 * If not homed, we need to do that first. */
			if(!qd_auto) {
				 rtapi_print_msg(RTAPI_MSG_ERR, "Tool Changer not Switched to AUTO Mode");
				 error_outputs = ERROR_NOT_AUTO_MODE;
				 cur_state = STATE_ERROR;
			} else if(completed) {
				/* completed is TRUE. We must wait for it to go FALSE before initiating a movement. */
				enqueue_state(STATE_INIT);
				cur_state = STATE_WAIT_COMPL_FALSE;
			} else {
				if(new_tool_in) {
					/* Only put a new tool in if asked to. Zero for new_tool_in means just 
					 *  take the old tool out. */
					enqueue_state(STATE_TOOL_IN);
					enqueue_state(STATE_CAROUSEL_MOVE);
				}
				if(homed_flag) {
					/* We assume if we're homed the carousel is already in position. So 
					 *  just take the tool out. */
					cur_state = STATE_TOOL_OUT;
				} else {
					/* Not homed. Take the tool out and home it. */
					enqueue_state(STATE_CAROUSEL_HOME);
					cur_state = STATE_TOOL_OUT;
				}
			}
			break; // STATE_INIT

		case STATE_WAIT_COMPL_FALSE:
			if(!qd_auto) {
				 rtapi_print_msg(RTAPI_MSG_ERR, "Tool Changer not Switched to AUTO Mode");
				 error_outputs = ERROR_NOT_AUTO_MODE;
				 cur_state = STATE_ERROR;
			} else if(state_changed) {
				// Initialize the timer on entering this state
				timer = 0.0;
			} else if(completed) {
				/* The debounced version of qd_complete is still TRUE. We need to wait for this to go
				 *  FALSE before going to next_state. */
				if(timer >= complete_max_time) {
					rtapi_print_msg(RTAPI_MSG_ERR, "qd-complete input (Quickdraw RESET output) set for too long");
					error_outputs = ERROR_QD_COMPLETE_STUCK_HIGH;
					cur_state = STATE_ERROR;
				}
			} else {
				/* OK to move on. */
				cur_state = dequeue_state();
			}
			break; // STATE_WAIT_COMPL_FALSE

		case STATE_TOOL_OUT: // Move the arm from spindle to carousel.
			if(!qd_auto) {
				 rtapi_print_msg(RTAPI_MSG_ERR, "Tool Changer not Switched to AUTO Mode");
				 error_outputs = ERROR_NOT_AUTO_MODE;
				 cur_state = STATE_ERROR;
			} else if(state_changed) {
				if(completed) {
					/* Wait for completed to go FALSE */
					enqueue_state(cur_state);
					cur_state = STATE_WAIT_COMPL_FALSE;
				} else {
					timer = 0.0;
					tool_out_output = TRUE;
				}
			} else {
				if(completed) {
					/* Done! */
					tool_out_output = FALSE;
					cur_state = dequeue_state();
				} else if(timer >= arm_move_timeout) {
					tool_out_output = FALSE;
					rtapi_print_msg(RTAPI_MSG_ERR, "Quickdraw Took Too Long to Move the Arm to the Carousel");
					error_outputs = ERROR_ARM_TO_CAROUSEL_FAIL;
					cur_state = STATE_ERROR;
				}
			}
			break; // STATE_TOOL_OUT

		case STATE_TOOL_IN: // Move the arm from spindle to carousel.
			if(!qd_auto) {
				 rtapi_print_msg(RTAPI_MSG_ERR, "Tool Changer not Switched to AUTO Mode");
				 error_outputs = ERROR_NOT_AUTO_MODE;
				 cur_state = STATE_ERROR;
			} else if(state_changed) {
				if(completed) {
					/* Wait for completed to go FALSE */
					enqueue_state(cur_state);
					cur_state = STATE_WAIT_COMPL_FALSE;
				} else {
					timer = 0.0;
					tool_in_output = TRUE;
				}
			} else {
				if(completed) {
					/* Done with the tool change. */
					tool_in_output = FALSE;
					cur_state = dequeue_state();
				} else if(timer >= arm_move_timeout) {
					tool_in_output = FALSE;
					rtapi_print_msg(RTAPI_MSG_ERR, "Quickdraw Took Too Long to Move the Arm to the Spindle");
					error_outputs = ERROR_ARM_TO_SPINDLE_FAIL;
					cur_state = STATE_ERROR;
				}
			}
			break; // STATE_TOOL_IN
	
		case STATE_CAROUSEL_MOVE: // Move to new tool position
			if(!qd_auto) {
				 rtapi_print_msg(RTAPI_MSG_ERR, "Tool Changer not Switched to AUTO Mode");
				 error_outputs = ERROR_NOT_AUTO_MODE;
				 cur_state = STATE_ERROR;
			} else if (state_changed) {
				if(completed) {
					/* Wait for completed to go FALSE */
					enqueue_state(cur_state);
					cur_state = STATE_WAIT_COMPL_FALSE;
				} else {
					/*  Start the timer, determine which way and how far to move the carousel, and start the movement. */
					timer = 0.0;
					if(!new_tool_in || (new_tool_in == cur_pocket_no)) {
						/* No move necessary. */
						cur_state = dequeue_state();
					} else {
						distance = new_tool_in - cur_pocket_no;
						move_cw = ((distance + changer_capacity) % changer_capacity) > (changer_capacity / 2);
						if(move_cw)
							carousel_cw_output = TRUE;
						else
							carousel_ccw_output = TRUE;
					}
				}
			} else if(!completed && was_completed) {
				/* The debounced completed input has just gone FALSE. Reset the timer */
				timer = 0.0;
			} else if(completed && was_completed) {
				/* Completed is high and was high in the previous cycle. Wait for it to go FALSE, 
				 *  but not past the timeout. We don't use the STATE_WAIT_COMPL_FALSE state since it might
				 *  require a two-level return stack. */
				if(timer >= complete_max_time) {
					rtapi_print_msg(RTAPI_MSG_ERR, "qd-complete input (Quickdraw RESET output) set for too long");
					error_outputs = ERROR_QD_COMPLETE_STUCK_HIGH;
					cur_state = STATE_ERROR;
				}
			} else if(completed && !was_completed) {
				/* completed has just gone TRUE. We've moved one tool. Reset the timer,
				 *  update the pocket number, and check if we've gone around the end. */
				timer = 0.0;
				if(move_cw) {
					// CW movement. Decreasing pocket numbers
					if(--cur_pocket_no <= 1)
						cur_pocket_no = changer_capacity;
				} else {
					// CCW movement. Increasing pocket numbers
					if(++cur_pocket_no > changer_capacity)
						cur_pocket_no = 1;
				}
				if(cur_pocket_no == new_tool_in) {
					/* We're done. Turn both directions off to be sure */
					carousel_cw_output = FALSE;
					carousel_ccw_output = FALSE;
					cur_state = dequeue_state();
				}
			} else if(!completed && (timer >= carousel_move_timeout)) {
				/* completed is still false and has timed out */
				carousel_cw_output = FALSE;
				carousel_ccw_output = FALSE;
				rtapi_print_msg(RTAPI_MSG_ERR, "Quickdraw took too long to move the carousel");
				error_outputs = ERROR_CAROUSEL_MOVE_FAIL;
				cur_state = STATE_ERROR;
			}
			break; // STATE_CAROUSEL_MOVE

		case STATE_CAROUSEL_HOME:
			if(!qd_auto) {
				 rtapi_print_msg(RTAPI_MSG_ERR, "Tool Changer not Switched to AUTO Mode");
				 error_outputs = ERROR_NOT_AUTO_MODE;
				 cur_state = STATE_ERROR;
			} else if(state_changed) {
				if(completed) {
					/* Wait for completed to go FALSE */
					enqueue_state(cur_state);
					cur_state = STATE_WAIT_COMPL_FALSE;
				} else {
					timer = 0.0;
					carousel_home_output = TRUE;
				}
			} else if(completed) {
				/* Done with homing the carousel. */
				carousel_home_output = FALSE;
				homed_flag = TRUE;
				cur_pocket_no = 1;
				cur_state = dequeue_state();
			} else if(timer >= carousel_home_timeout) {
				carousel_home_output = FALSE;
				rtapi_print_msg(RTAPI_MSG_ERR, "Quickdraw took too long to home the carousel");
				error_outputs = ERROR_CAROUSEL_HOME_FAIL;
				cur_state = STATE_ERROR;
			}
			break; // STATE_CAROUSEL_HOME
		
		case STATE_ERROR:
			/* Do nothing, but recover when the machine gets turned on. */
			if(!was_on && is_on)
				// We always go back to the idle state, but need to clear the stack
				state_index = 0;
				cur_state = STATE_IDLE;
				error_outputs = 0;
			break; // STATE_ERROR
	}
	current_state = cur_state;
	current_tool = cur_pocket_no;
	error_mask = error_outputs;
	change_ack = ack_out;
}

EXTRA_SETUP() {
	state_stack[0] = STATE_IDLE;
	prev_state = cur_state = STATE_IDLE;
	return 0;
}
