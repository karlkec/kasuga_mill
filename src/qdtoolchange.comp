/********************************************************************
* Description:  qdtoolchange.comp
*
* Author: Karl Cunningham
* License: LGPL Version 3 or later
*
* Copyright (c) 2011 All rights reserved.
*
********************************************************************
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of version 2 or later of the GNU General
 * Public License as published by the Free Software Foundation.
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111 USA
 *
 * THE AUTHORS OF THIS LIBRARY ACCEPT ABSOLUTELY NO LIABILITY FOR
 * ANY HARM OR LOSS RESULTING FROM ITS USE.  IT IS _EXTREMELY_ UNWISE
 * TO RELY ON SOFTWARE ALONE FOR SAFETY.  Any machinery capable of
 * harming persons must have provisions for completely removing power
 * from all motors, etc, before persons enter any danger area.  All
 * machinery must be designed to comply with local and national safety
 * codes, and the authors of this software can not, and do not, take
 * any responsibility for such compliance.
 *
 * This code was written as part of the EMC HAL project.  For more
 * information, go to www.linuxcnc.org.
 *
*************************************************************************/

component qdtoolchange "EMC HAL component to manage Dana Summit Quickdraw tool changer";

pin in bit tool_change "Request a tool change. Normally comes from iocontrol.0.tool-change";
pin in signed tool_num "The number of the desired new tool. Range is 0 to the turret-capacity \
parameter (see below). Normally wired to iocontrol.0.tool-prep-number";
pin in bit machine_on "Tells this component that the machine is on. Normally wired to halui.machine.is-on";
pin in bit qd_complete "Reset signal from the Quickdraw Tool Changer that the current operation is complete.\
This should be wired to the contact closure which occurs between the white/black and grey wires (pins 11 and 12 of J7) \
of the Quickdraw M-Function cable.";
pin in bit qd_auto "Indication that the tool changer is in auto mode. This can be obtained with a \
connection to pin 9 (+12V) of the tool changer M-interface connector J7, using pin 8 of J11 as a \
ground reference. J11 is located directly below J7 in the tool changer electronics.";
pin in bit claw_open "Indication that the claw is being held in the opon position. This, along \
with the qd_complete bit above, means that the Quickdraw hardware is finished with the tool change. \
This should be wired to the contact closure which occurs between the white/red and white/orn wires \
in the M-Function cable from the Quickdraw hardware.";
pin in bit error_reset "Operator Error Reset button. Used to clear errors.";

/* Pins to control the Quickdraw hardware */
pin out bit tool_in_command "Tool-In command to the tool changer, to remove the tool from the carousel \
and lock it into the spindle. This should be connected to the Orange wire of the M-Function cable \
(pin 5 of connector J7).";
pin out bit tool_out_command "Tool-Out command to the tool changer, to remove the tool from the spindle \
and place it in the carousel. This should be connected to the Green wire of the M-Function cable \
(pin 4 of connector J7).";
pin out bit carousel_cw_command "Turret CW command to the tool changer. This should be connected to the \
Brown wire of the M-Function cable (pin 7 of connector J7).";
pin out bit carousel_ccw_command "Turret CCW command to the tool changer. This should be connected to the \
Yellow wire of the M-Function cable (pin 6 of connector J7).";
pin out bit carousel_home_command "Turret Home command to the tool changer. This should be connected to the \
Blue wire of the M-Function cable (pin 6 of connector J7).";

/* Output pins for interface and statua. */
pin out bit tool_changed "True when the a tool change is complete. Normally this is connected to iocontrol.0.tool-changed.";
pin out bit is_homed "True when tool changer carousel has been homed. If the tool changer is switched from \
AUTO mode, it is assumed to be unhomed since manual movement of the carousel may have occurred.";
pin out bit ready "True when qd_auto and claw_open are both TRUE.";
pin out unsigned error_code "Error Code output. See description for codes.";
pin out bit error_flag "Goes TRUE when this component is in an error condition.";
pin out bit fault "Fatal error. This is should be wired to halui.estop.activate, or something which will abort the tool change request. \
Otherwise, iocontrol will wait forever for change-complete, which can never happen.";
pin out signed current_tool "Carousel pocket number currently in position. Will be zero if not homed.";

// For debugging
pin out signed current_state "For debugging. State of the internal state machine";

/* Parameters for controlling timouts and capacity */
param rw unsigned changer_capacity=24 "Max number of tools the tool changer is capable of handling. Default = 24";
param rw unsigned carousel_home_timeout=45 "Maximum time in seconds to allow the carousel to home. Default = 45 sec";
param rw unsigned carousel_move_timeout=3 "Maximum time in seconds to allow the carousel to move one tool position. Default = 3 sec";
param rw unsigned arm_move_timeout=15.0 "Maximum time in seconds to allow for moving a tool from the carousel to or from the spindle. Default = 15 sec";
param rw unsigned claw_open_timeout=1000 "Maximum time in MILLIseconds to allow the claw to open after a tool in or tool out is complete";
param rw unsigned complete_max_time=1000 "Maximum time in MILLIseconds to allow the complete input to remain high before issuing an error. Default = 1000 msec";
param rw unsigned debounce_period=40 "Time in MILLIseconds for all debouncing. Default = 40 msec";

description """

qdtoolchange manages the Dana Summit Quickdraw tool changer. This is a
real-time hal component which receives tool change commands and controls the
\\fBDana Summit Quickdraw\\fR hardware to perform the tool change. 

The tool changer hardware has five inputs to command various actions of the
tool changer, and two outputs which give operational feedback. The RESET
hardware output signals that the previously-commanded operation is complete (or
that the carousel has moved one tool pocket), and the AUTO-MODE output
is used to determine whether the tool changer front panel switch is set to the
AUTO position. If the switch is placed in the MAN or LOC positions, this
component assumes the operator may have moved the carousel and deems the
carousel unhomed. This forces a homing operation before any tools can be used.

This component attempts to track the state of the tool changer hardware. But
since it only has dynamic feedback for arm and carousel movements, when asked
to change a tool for the first time it must remove any tool from the spindle
and home the carousel. Once feedback is received that these operations are
complete, the state of the hardware is known. It is important that an empty
pocket be in position before running a program which uses tool changes, or
making a tool change in MDI mode.

To allow manual or automatic tool changes, hal signal
\\fBiocontrol.tool-change\\fR should be directed to either a manual tool change
component such as hal_manualtoolchange, or to this component's toolchange-req.
The \\fBtool-changed\\fR output pin from this and the corresponding pin from
the manual tool change component should be or-ed together and fed to
\\fBiocontrol.0.tool-change.\\fR The \\fBiocontrol.tool-prep-number\\fR should be
sent to both the manual tool change and to this component.

There are a number of conditions which result in an error. In all cases errors
will cause an RTAPI error to be issued, which should appear on the operator
screen. Errors are divided into fatal and non-fatal errors. Generally fatal
errors are ones from which easy recovery is not possible, such as a hardware
timeout or if a tool number is requested which is outside the capability of the
tool changer hardware. Non-fatal errors such as a lack of air pressure can be
corrected and the tool change completed by asserting the \\fBerror-reset\\fR input pin
without interrupting the program in progress. Fatal errors will assert the
fault output pin, which should perform an estop or something similar to
aborts the running program and set the \\fBtool-change\\fR pin FALSE.  Both fatal and
non-fatal errors assert the \\fBerror_flag\\fR output pin, which can serve to
alert the operator. After a any error, the operator should press a reset
button or similar, which asserts the \\fBerror_reset\\fR pin to clear the
error. This input pin is edge sensitive, so wiring it TRUE won't do.

Note that as of emc2 version 2.4.6, axis is largely unresponsive to user input
while it is waiting for the \\fBiocontrol.0.tool-changed\\fR pin to go TRUE.

When this component gets a tool change request from iocontrol, it evaluates the
homed status, the \\fBtool-num\\fR, and the number of the tool in the spindle.
If the requested tool number is zero, any tool in the spindle is placed in the
carousel.

If the carousel is not homed,
the tool in the spindle is moved to the carousel and the carousel homed. It is assumed that there is an empty pocket in the carousel positioned to accept the tool from the spindle. After homing, 
if a different tool is needed, it
moves the carousel to the new tool and puts it into the spindle. It then evaluates the homed
status and the new tool number. If the tool changer carousel has not been homed
since this component was started or was issued an \\fBerror_reset\\fR, the
carousel will be homed first. The carousel will then be moved to the new tool's
pocket, and that tool moved to the spindle.

Note that since the Quickdraw tool changer cannot prepare a tool before it is
needed, there must be a hal loopback connection between the prepare tool
request and the tool_prepared answer, like this:
net tool-prepare-loopback iocontrol.0.tool-prepare => iocontrol.0.tool-prepared

When an error occurs, bits in the error-mask output pin indicate what the error is:
0 -- No Error
1 -- Invalid \\fBtool-num\\fR input
2 -- Spindle-to-Carousel Arm Movement Timed Out
3 -- Carousel-to-Spindle Arm Movement Timed Out
4 -- \\fBqd_complete\\fR Input Stuck Low
5 -- \\fBqd_complete\\fR Input Stuck High
6 -- Carousel Movement Timed Out
7 -- Carousel Home Operation Timed Out
8 -- \\fBqd-auto\\fR not TRUE (Auto Mode not Selected on Quickdraw Front Panel)
9 -- Claw Open Signal not Seen at Start of Tool Change. Possible Air Pressure Problem
10 -- Claw Opening Timed Out
""";

license "GPL";
author "K. Cunningham";
option singleton yes;
option extra_setup yes;
function _ nofp;
;;

typedef enum {
	ERROR_NO_ERROR = 0,
	ERROR_INVALID_NEW_TOOL, // 1
	ERROR_ARM_TO_CAROUSEL_FAIL, // 2
	ERROR_ARM_TO_SPINDLE_FAIL, // 3
	ERROR_QD_COMPLETE_STUCK_LOW, // 4
	ERROR_QD_COMPLETE_STUCK_HIGH, // 5
	ERROR_CAROUSEL_MOVE_FAIL, // 6
	ERROR_CAROUSEL_HOME_FAIL, // 7
	ERROR_NOT_AUTO_MODE, // 8
	ERROR_NOT_CLAW_OPEN, // 9
	ERROR_CLAW_OPEN_TIMEOUT, // 10
	NUM_ERROR_CODES
} error_codes;

const char *error_str[] = {
	"Quickdraw Tool Changer -- No Error",
	"Quickdraw Tool Changer -- Tool Number out of Range\nPress RESET to Clear",
	"Quickdraw Tool Changer -- Took Too Long to Move Arm to Carousel\nPress RESET to Clear",
	"Quickdraw Tool Changer -- Took Too Long to Move Arm to Spindle\nPress RESET to Clear",
	"Quickdraw Tool Changer -- Reset Output from Tool Changer did not Actuate\nPress RESET to Clear",
	"Quickdraw Tool Changer -- Reset Output from Tool Changer Stuck On\nPress RESET to Clear",
	"Quickdraw Tool Changer -- Took Too Long to Move the Carousel\nPress RESET to Clear",
	"Quickdraw Tool Changer -- Took Too Long to Home the Carousel\nPress RESET to Clear",
	"Quickdraw Tool Changer -- Please Turn the Tool changer ON in AUTO Mode",
	"Quickdraw Tool Changer -- Claw not Open. Got Compressed Air?",
	"Quickdraw Tool Changer -- Claw Open Timed Out. Got Compressed Air?",
};

// Time conversions
#define NSPERSEC  1000000000ULL
#define NSPERMSEC 1000000ULL

// State names defined
typedef enum {
	STATE_IDLE = 0, // 0
	STATE_INIT, // 1
	STATE_TOOL_OUT, // 2
	STATE_TOOL_IN, // 3
	STATE_CAROUSEL_MOVE, // 4
	STATE_CAROUSEL_HOME, // 5
	STATE_WAIT_CLAW_OPEN, // 6
	STATE_WAIT_COMPL_FALSE, // 7
	STATE_CLAW_ERROR, // 8
	STATE_AUTO_ERROR, // 9
	STATE_FAULT // 10
} States;

#define STATE_STACK_DEPTH 10
static int state_stack[STATE_STACK_DEPTH];
static int state_index;
static short cur_state;
static short prev_state;
static unsigned long long timer;
static bool completed; // Debounced state of the complete input pin
static int new_tool_in;
static int move_cw; // Move the carousel CW
static bool homed_flag; // Whether the tool changer carousel has been homed.
static bool is_on; // Current state of machine_on
static int cur_pocket_no; // The tool pocket currently in position. 0 if not homed
static int error_output; // ORed error conditions
static bool done;
static long long compl_accum;
static long long claw_accum;
static long long auto_accum;

static bool state_changed;
static bool claw_open_deb; // Debounced state of the claw-open input pin
static bool qd_auto_deb; // Debounced state of qd_auto
static bool was_completed;
static bool was_error_reset; // Previous state of error_reset
static bool is_error_reset;
static bool was_on; // Previous state of pgm_running
static int distance;
static bool was_error; // Previous pass was in error state.
static bool fault_out; // Abort the currently-running program


/* The state LIFO stack array works from index 0 up. The bottom state is always
 *  STATE_IDLE. */
inline void enqueue_state(int state) {
	/* Pushes a new state on our stack. If the stack is full, does nothing */
	if(state_index < (STATE_STACK_DEPTH - 1))
		state_stack[++state_index] = state;
}

inline int dequeue_state(void) {
	/* Pops the next state from the state stack. the bottom state is 
	 *  always STATE_IDLE.
	 */
	short new_state;
	if(state_index > 0) {
		/* Reset the state index to the base state if going back to IDLE. */
		new_state = state_stack[state_index--];
		if(new_state == STATE_IDLE)
			state_index = 0;
		return new_state;
	} else {
		return STATE_IDLE;
	}
}

FUNCTION(_) {
	/* Maintain the timer. Used for hardware timouts */
	timer += period;	

	/* Debounce the needed input pins. Debounce is done by adding elapsed time to
	 * an accumulator while the bit is TRUE and subtracting elapsed time while the
	 * bit is FALSE. The accumulator is limited between 0 and debounce_period. If
	 * the accumulator reaches debounce_period, the bit is deemed TRUE. If it
	 * reaches 0, the bit is deemed FALSE. */
	was_completed = completed; // save previous value
	if(qd_complete) { // Input is high
		if(compl_accum < (long long)debounce_period * NSPERMSEC) 
			compl_accum += period;
		else
			completed = TRUE;
	} else { // Input is low
		if(compl_accum > 0)
			compl_accum -= period;
		else
			completed = FALSE;
	}
	if(claw_open) { // Input is high
		if(claw_accum < (long long)debounce_period * NSPERMSEC) 
			claw_accum += period;
		else
			claw_open_deb = TRUE;
	} else { // Input is low
		if(claw_accum > 0)
			claw_accum -= period;
		else
			claw_open_deb = FALSE;
	}
	if(qd_auto) { // Input is high
		if(auto_accum < (long long)debounce_period * NSPERMSEC) 
			auto_accum += period;
		else
			qd_auto_deb = TRUE;
	} else { // Input is low
		if(auto_accum > 0)
			auto_accum -= period;
		else
			/* Unhome the tool changer if the Quickdraw hardware has been switched from AUTO mode */
			qd_auto_deb = FALSE;
			homed_flag = FALSE;
			cur_pocket_no = 0;
	}

	/* Maintain the past and current states. */
	was_on = is_on;
	is_on = machine_on;
	was_error_reset = is_error_reset;
	is_error_reset = error_reset;
			
	state_changed = (cur_state != prev_state);
	was_error = (prev_state == STATE_FAULT) || (prev_state == STATE_CLAW_ERROR) || (prev_state == STATE_AUTO_ERROR);
	if(state_changed) {
		prev_state = cur_state;
	} 

	/* If the machine is off, don't do anything. Turn off all the outputs. */
	if(!is_on) {
		tool_in_command = FALSE;
		tool_out_command = FALSE;
		carousel_cw_command = FALSE;
		carousel_ccw_command = FALSE;
		carousel_home_command = FALSE;
	}

	/* On entering each state other than IDLE, check for AUTO mode. If not, it's an error. */
	switch(cur_state) {
		case STATE_IDLE: // Check tool_change for a new tool request.
			if(state_changed) {
				/* If we didn't just recover from an error, we must have completed the operation. */
				if(!was_error)
					done = TRUE;
			} else if(tool_change && !done) {
				/* Latch the new tool inputs. */
				new_tool_in = tool_num;
				if(new_tool_in < 0 || new_tool_in > changer_capacity) {
					error_output = ERROR_INVALID_NEW_TOOL;
					cur_state = STATE_FAULT;
					fault_out = TRUE; // Fatal error
				} else {
					/* All OK. Continue */
					cur_state = STATE_INIT;
				}
			} else if(!tool_change && done) {
				/* Release the done flag only when the tool_change goes FALSE. */
				done = FALSE;
			}
			break; // STATE_IDLE

		case STATE_INIT:
			/* Check state of hardware and take action if needed. Otherwise, start the tool change.
			 * If not homed, we need to do that first. */
			if(!qd_auto_deb) {
				 error_output = ERROR_NOT_AUTO_MODE;
				 cur_state = STATE_AUTO_ERROR;
			} else if(completed) {
				/* completed is TRUE. We must wait for it to go FALSE before initiating a movement. */
				enqueue_state(STATE_INIT);
				cur_state = STATE_WAIT_COMPL_FALSE;
			} else if(!claw_open_deb) {
				/* The claw-open signal is not present. We can't proceed without that. Probably no
				 *  air line connected. */
				error_output = ERROR_NOT_CLAW_OPEN;
				cur_state = STATE_CLAW_ERROR;
			} else {
				/* No error condition. Determine what operations to perform. Enqueuing states
				 *  loads a LIFO, so we load them in reverse order. */
				if(!new_tool_in) {
					/* Just remove the old tool regarless of whether the carousel is homed or not. */
					cur_state = STATE_TOOL_OUT;
				} else if(homed_flag) {
					if(new_tool_in == cur_pocket_no) {
						/* The carousel is homed and at the right position. We don't need to remove
						 *  the current tool (if there is one in the spindle). Just put one in if
						 *  the arm is at the carousel. */
						cur_state = STATE_TOOL_IN;
					} else {
						/* It's homed and we need a differnet tool. Move the carousel to the new tool (if needed)
						 *  and put it in. */
						enqueue_state(STATE_TOOL_IN);
						enqueue_state(STATE_CAROUSEL_MOVE);
						cur_state = STATE_TOOL_OUT;
					}
				} else { // Not homed and we need a new tool.
					enqueue_state(STATE_TOOL_IN);
					enqueue_state(STATE_CAROUSEL_MOVE);
					enqueue_state(STATE_CAROUSEL_HOME);
					cur_state = STATE_TOOL_OUT;
				}
			}
			break; // STATE_INIT

		case STATE_TOOL_OUT: // Move the arm from spindle to carousel.
			if(state_changed) {
				if(completed) {
					/* Wait for completed to go FALSE */
					enqueue_state(cur_state);
					cur_state = STATE_WAIT_COMPL_FALSE;
				} else {
					timer = 0;
					tool_out_command = TRUE;
				}
			} else if(!qd_auto_deb) {
				/* Not in AUTO mode any more. Stop the operation and wait for it to
				 *  get turned on again. */
				enqueue_state(cur_state);
				tool_out_command = FALSE;
				error_output = ERROR_NOT_AUTO_MODE;
				cur_state = STATE_AUTO_ERROR;
			} else if(completed) {
				/* Done! Wait for the claw to open before moving on. */
				tool_out_command = FALSE;
				cur_state = STATE_WAIT_CLAW_OPEN;
			} else if(timer >= (unsigned long long)arm_move_timeout * NSPERSEC) {
				tool_out_command = FALSE;
				error_output = ERROR_ARM_TO_CAROUSEL_FAIL;
				cur_state = STATE_FAULT;
				fault_out = TRUE; // Fatal error
			}
			break; // STATE_TOOL_OUT

		case STATE_TOOL_IN: // Move the arm from carousel to spindle.
			if(state_changed) {
				if(completed) {
					/* Wait for completed to go FALSE */
					enqueue_state(cur_state);
					cur_state = STATE_WAIT_COMPL_FALSE;
				} else {
					timer = 0;
					tool_in_command = TRUE;
				}
			} else if(!qd_auto_deb) {
				/* Not in AUTO mode any more. Abort the operation. */
				enqueue_state(STATE_IDLE);
				tool_in_command = FALSE;
				error_output = ERROR_NOT_AUTO_MODE;
				cur_state = STATE_AUTO_ERROR;
			} else if(completed) {
				/* Done with the tool change. Wait for the claw to open before moving on. */
				tool_in_command = FALSE;
				cur_state = STATE_WAIT_CLAW_OPEN;
			} else if(timer >= (unsigned long long)arm_move_timeout * NSPERSEC) {
				tool_in_command = FALSE;
				error_output = ERROR_ARM_TO_SPINDLE_FAIL;
				cur_state = STATE_FAULT;
				fault_out = TRUE; // Fatal error
			}
			break; // STATE_TOOL_IN
	
		case STATE_CAROUSEL_MOVE: // Move to new tool position
			if (state_changed) {
				if(completed) {
					/* Wait for completed to go FALSE */
					enqueue_state(cur_state);
					cur_state = STATE_WAIT_COMPL_FALSE;
				} else {
					/*  Start the timer, determine which way and how far to move the carousel, and start the movement. */
					timer = 0;
					if(!new_tool_in || (new_tool_in == cur_pocket_no)) {
						/* No move necessary. */
						cur_state = dequeue_state();
					} else {
						distance = new_tool_in - cur_pocket_no;
						move_cw = ((distance + changer_capacity) % changer_capacity) > (changer_capacity / 2);
						if(move_cw)
							carousel_cw_command = TRUE;
						else
							carousel_ccw_command = TRUE;
					}
				}
			} else if(!qd_auto_deb) {
				/* Not in AUTO mode any more. Abort the operation. */
				enqueue_state(STATE_IDLE);
				carousel_cw_command = FALSE;
				carousel_ccw_command = FALSE;
				error_output = ERROR_NOT_AUTO_MODE;
				cur_state = STATE_AUTO_ERROR;
			} else if(!completed && was_completed) {
				/* The debounced completed input has just gone FALSE. Reset the timer */
				timer = 0;
			} else if(completed && was_completed) {
				/* Completed is high and was high in the previous cycle. Wait for it to go FALSE, 
				 *  but not past the timeout. */
				if(timer >= complete_max_time * NSPERMSEC) {
					error_output = ERROR_QD_COMPLETE_STUCK_HIGH;
					cur_state = STATE_FAULT;
					fault_out = TRUE; // Fatal error
				}
			} else if(completed && !was_completed) {
				/* completed has just gone TRUE. We've moved one tool. Reset the timer,
				 *  update the pocket number, and check if we've gone around the end. */
				timer = 0;
				if(move_cw) {
					// CW movement. Decreasing pocket numbers
					if(--cur_pocket_no < 1)
						cur_pocket_no = changer_capacity;
				} else {
					// CCW movement. Increasing pocket numbers
					if(++cur_pocket_no > changer_capacity)
						cur_pocket_no = 1;
				}
				if(cur_pocket_no == new_tool_in) {
					/* We're done. Turn both directions off to be sure */
					carousel_cw_command = FALSE;
					carousel_ccw_command = FALSE;
					cur_state = dequeue_state();
				}
			} else if(!completed && (timer >= (unsigned long long)carousel_move_timeout * NSPERSEC)) {
				/* completed is still false and has timed out */
				carousel_cw_command = FALSE;
				carousel_ccw_command = FALSE;
				error_output = ERROR_CAROUSEL_MOVE_FAIL;
				cur_state = STATE_FAULT;
				fault_out = TRUE;
			}
			break; // STATE_CAROUSEL_MOVE

		case STATE_CAROUSEL_HOME:
			if(state_changed) {
				if(completed) {
					/* Wait for completed to go FALSE */
					enqueue_state(cur_state);
					cur_state = STATE_WAIT_COMPL_FALSE;
				} else {
					timer = 0;
					carousel_home_command = TRUE;
				}
			} else if(!qd_auto_deb) {
				/* Not in AUTO mode any more. Abort the operation. */
				enqueue_state(STATE_IDLE);
				carousel_home_command = FALSE;
				error_output = ERROR_NOT_AUTO_MODE;
				cur_state = STATE_AUTO_ERROR;
			} else if(completed) {
				/* Done with homing the carousel. */
				carousel_home_command = FALSE;
				homed_flag = TRUE;
				cur_pocket_no = 1;
				cur_state = dequeue_state();
			} else if(timer >= (unsigned long long)carousel_home_timeout * NSPERSEC) {
				carousel_home_command = FALSE;
				error_output = ERROR_CAROUSEL_HOME_FAIL;
				cur_state = STATE_FAULT;
				fault_out = TRUE; // Fatal error
			}
			break; // STATE_CAROUSEL_HOME
		
		case STATE_WAIT_COMPL_FALSE:
			/* Don't test for AUTO mode here. If the tool changer is hung up and the opreator switches
			 *  to MANual mode to fix it, we don't want to create yet another error. */
			if(state_changed) {
				// Initialize the timer on entering this state
				timer = 0;
			} else if(completed) {
				/* The debounced version of qd_complete is still TRUE. We need to wait for this to go
				 *  FALSE before going to the next_state. */
				if(timer >= complete_max_time * NSPERMSEC) {
					error_output = ERROR_QD_COMPLETE_STUCK_HIGH;
					cur_state = STATE_FAULT;
					fault_out = TRUE; // Fatal error
				}
			} else {
				/* OK to move on. */
				cur_state = dequeue_state();
			}
			break; // STATE_WAIT_COMPL_FALSE

		case STATE_WAIT_CLAW_OPEN:
			/* Don't test for AUTO mode here. The claw open signal should come
			 * back regarless of whether the tool changer is in AUTO mode or
			 * not (claw open is the default state of the changer). */
			if(state_changed) {
				timer = 0;
			} else if(claw_open_deb) {
				/* Claw opened in time. OK to move on. */
				cur_state = dequeue_state();
			} else if(timer > claw_open_timeout * NSPERMSEC) {
				/* Claw took too long to open */
				error_output = ERROR_CLAW_OPEN_TIMEOUT;
				cur_state = STATE_CLAW_ERROR;
			}
			break;

		case STATE_CLAW_ERROR:
			if(state_changed) {
				rtapi_print_msg(RTAPI_MSG_ERR,error_str[error_output]);
			} else if(is_error_reset && !was_error_reset && claw_open_deb) {
				/* The claw has been opened (or the operator connected the air
				 *  hose, and the reset button was pressed. Move on. */
				if(!qd_auto_deb) {
					/* Claw is open but now we're not in AUTO mode. Go to that
					 *  Error state. */
					error_output = ERROR_NOT_AUTO_MODE;
					cur_state = STATE_AUTO_ERROR;
				} else {
					error_output = ERROR_NO_ERROR;
					cur_state = dequeue_state();
				}
			} else if(is_error_reset && !was_error_reset) {
				/* The operator pressed the reset button but we still don't have
				 * a claw-open signal. Issue the error message again. */
				rtapi_print_msg(RTAPI_MSG_ERR,error_str[error_output]);
			}
			break; // STATE_CLAW_ERROR

		case STATE_AUTO_ERROR:
			if(state_changed) {
				rtapi_print_msg(RTAPI_MSG_ERR,error_str[error_output]);
			} else if(is_error_reset && !was_error_reset && qd_auto_deb) {
				/* The operator has switched on the tool changer to AUTO mode, and 
				 *  pressed the reset button. Time to move on. */
				error_output = ERROR_NO_ERROR;
				cur_state = dequeue_state();
			} else if(is_error_reset && !was_error_reset) {
				/* The operator has pressed the reset button but it's still not
				 *  in AUTO mode. Issue the error message again. */
				rtapi_print_msg(RTAPI_MSG_ERR,error_str[error_output]);
			}
			break; // STATE_AUTO_ERROR

		case STATE_FAULT:
			/* If the machine is on, display the error message, then do nothing, but recover when the machine is 
			 *  turned off. */
			if(state_changed && is_on) {
				rtapi_print_msg(RTAPI_MSG_ERR,error_str[error_output]);
			} else if(is_error_reset && !was_error_reset) {
				/* Clear the fault when the operator presses the reset button. Note that
				 *  without testing for the previous state, it gets stuck with the repeating
				 *  error message. Dunno why.  */
				state_index = 0;
				cur_state = STATE_IDLE;
				fault_out = FALSE;
				error_output = ERROR_NO_ERROR;
				// When the operator resets a fault, unhome the carousel.
				homed_flag = FALSE;
			}
			break; // STATE_FAULT
	}
	current_state = cur_state;
	current_tool = cur_pocket_no;
	error_code = error_output;
	error_flag = (error_code != 0);
	tool_changed = (done && claw_open_deb);
	is_homed = homed_flag;
	ready = (cur_state == STATE_IDLE) && is_on && qd_auto_deb && claw_open_deb;
	fault = fault_out;
}

EXTRA_SETUP() {
	state_stack[0] = STATE_IDLE;
	prev_state = cur_state = STATE_IDLE;
	return 0;
}
