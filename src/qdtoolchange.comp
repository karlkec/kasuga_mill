component qdtoolchange "EMC HAL component to manage Dana Summit Quickdraw tool changer";

pin in bit toolchange_req "Request from M6 that a tool change is required. Normally comes from iocontrol.0.tool-change";
pin in signed new_tool_no "The number of the desired new tool. Range is 0 to parameter turret_capacity. Normally wired to iocontrol.n.tool-prep-number";
pin in bit qd_complete "Reset signal from the Quickdraw Tool Changer that the current operation is complete";
pin in bit machine_on "Tell this component that a the machine is on. Normally wired to halui.machine.is-on. Used to reset error conditions";
pin in bit qd_auto "Indication that the tool changer is in auto mode. Connected to pin 9 (+12V) of the tool changer interface connector";
pin in bit claw_open "Indication that the claw is being held in the opon position. This, along with the qd_complete bit above, means that the hardware is finished with the tool change";

pin out bit tool_in_output "Tool-In command to the tool changer. Moves the arm to the spindle";
pin out bit tool_out_output "Tool-Out command to the tool changer. Moves the arm to the carousel";
pin out bit carousel_cw_output "Turret CW command to the tool changer. Moves the carousel clockwise";
pin out bit carousel_ccw_output "Turret CCW command to the tool changer. Moves the carousel counterclockwise";
pin out bit carousel_home_output "Turret Home command to the tool changer.";
pin out bit change_ack "True when the a tool change is complete. Normally this is connected to iocontrol.0.tool-prepared";
pin out bit is_homed "True when tool changer carousel is homed";

pin out unsigned error_mask "Error Output. See description";
pin out signed current_tool "For debugging. Tool number currently in position. Will be zero until homed";
pin out signed current_state "For debugging. State of the internal state machine";

param rw float carousel_home_timeout=45.0 "Maximum time in seconds to allow the carousel to home. Default = 45 sec";
param rw float carousel_move_timeout=3.0 "Maximum time in seconds to allow the carousel to move one tool position. Default = 3.0 sec";
param rw float arm_move_timeout=15.0 "Maximum time in seconds to allow for moving a tool from the carousel to or from the spindle. Default = 15 sec";
param rw float complete_max_time=1.0 "Maximum time in seconds to allow the complete input to remain high before flagging an error. Default = 1.0 sec";
param rw unsigned changer_capacity=24 "Max number of tools the tool changer is capable of handling. Default = 24";
param rw float debounce_period=0.04 "Time in seconds for debouncing. Default = 0.040 sec";

variable short cur_state;
variable short prev_state;
variable bool state_changed;
variable float timer;
variable bool claw_open_deb; // Debounced state of the claw-open input pin
variable bool completed; // Debounced state of the complete input pin
variable int new_tool_in;
variable int move_cw; // Move the carousel CW
variable bool homed_flag; // Whether the tool changer carousel has been homed.
variable bool is_on; // Current state of machine_on
variable int cur_pocket_no; // The tool pocket currently in position. 0 if not homed
variable int error_outputs; // ORed error conditions
variable bool done;

description """
qdtoolchange manages the Dana Summit Quickdraw tool changer.o

The \\fBQuickdraw\\fR tool changer hardware has five command inputs and one output
(RESET). The RESET output is a relay whose contacts close when the
previously-commanded operation is completed. The five hardware command
inputs are TURRET CW, TURRET CCW, TURRET HOME, TOOL IN, and TOOL OUT. In
addition, this component requires a connection to the +12V on the
M-POSITITION connector, and the GROUND pin on J7. This pair is used to
determine whether the tool changer front panel has been switched away from
the AUTO position. If this happens, this component assumes the operator may
have moved the carousel and so deems the hardware unhomed, which will
require a homing operation before any tools can be used.

When this component gets a tool change request from iocontrol, it evaluates
the homed status and the new tool number. If the tool changer is not homed,
the changer will be homed first. If there is a tool in the spindle it will
be returned to the carousel at its current location, then the carousel
homed if needed, then the carousel will be moved to the new tool, and that
tool moved to the spindle.

Note that since the Quickdraw tool changer cannot prepare a tool before it
is needed, there must be a hal loopback connection between the prepare tool
request and the tool_prepared answer, like this: net tool-prepare-loopback
iocontrol.0.tool-prepare => iocontrol.0.tool-prepared

When an error occurs, bits in the error-mask output pin indicate what the error is:
0 -- No Error
1 -- Invalid new_tool_no input
4 -- Spindle-to-Carousel Arm Movement Timed Out
8 -- Carousel-to-Spindle Arm Movement Timed Out
16 -- qd_complete Input Stuck Low
32 -- qd_complete Input Stuck High
64 -- Carousel Movement Timed Out
128 -- Carousel Home Operation Timed Out
256 -- Auto Mode not Selected on Quickdraw Front Panel
512 -- Claw Open Signal not Seen. Possible Air Pressure Problem

The operation of this component is as a state machine. It has 8 states, described here:
0. STATE_IDLE -- Does nothing except to monitor for a new tool request.
1. STATE_WAIT_COMPL_FALSE -- Waits for the debounced complete input has gone FALSE. If the time 
exceeds complete_max_time, issues an error.
2. STATE_INIT -- Entered when a new tool request is received. Does the following:
a. Check that the carousel has been homed. If not, home it now.
b. Check whether the new requested tool and the previous tool are the same. If so sets complete and 
returns to idle.
c. Check that the complete input pin is FALSE. If not, wait for it but not longer than complete_max_time
d. Determines how far and in which direction to move the carousel to the next desired tool.
e. Sets the CHANGING output to TRUE.
f. Starts the main timer.
g. Sets the next state, which depends on the input pins.
3. STATE_TOOL_OUT -- Issues a TOOL_OUT command to the hardware and waits for completion or timeout.
4. STATE_TOOL_IN -- Issues a TOOL_IN command to the hardware and waits for completion or timeout.
5. STATE_CAROUSEL_MOVE -- Issues carousel_cw_output or carousel_ccw_output commands to the hardare.
Counts complete pulses to determine when the new tool is in the active position.
6. STATE_CAROUSEL_HOME -- Issues a carousel_home_output command to the hardware and waits for completion or timeout.
7. STATE_ERROR -- Entered if an error occurs. Changes to STATE_IDLE when machine is turned from off to on.
""";

license "GPL";
author "K. Cunningham";
option singleton yes;
option extra_setup yes;
function _;
;;

// Codes for error_mask for each error
#define ERROR_INVALID_NEW_TOOL 1
#define ERROR_INVALID_CUR_TOOL 2
#define ERROR_ARM_TO_CAROUSEL_FAIL 4
#define ERROR_ARM_TO_SPINDLE_FAIL 8
#define ERROR_QD_COMPLETE_STUCK_LOW 0x10
#define ERROR_QD_COMPLETE_STUCK_HIGH 0x20
#define ERROR_CAROUSEL_MOVE_FAIL 0x40
#define ERROR_CAROUSEL_HOME_FAIL 0x80
#define ERROR_NOT_AUTO_MODE 0x100
#define ERROR_NOT_CLAW_OPEN 0x200

// Items to debounce
typedef enum {
	DEBOUNCE_QD_COMPLETE = 0,
	DEBOUNCE_QD_JAW_OPEN,
	DEBOUNCE_QD_AUTO,
	MAX_DEBOUNCE_ITEMS
} debounce_items;

typedef struct {
	float accum;
	bool state;
} debounce_status;


// State names defined
typedef enum {
	STATE_IDLE = 0,
	STATE_INIT,
	STATE_TOOL_OUT,
	STATE_TOOL_IN,
	STATE_CAROUSEL_MOVE,
	STATE_CAROUSEL_HOME,
	STATE_WAIT_COMPL_FALSE,
	STATE_ERROR
} States;

#define STATE_STACK_DEPTH 10
static int state_stack[STATE_STACK_DEPTH];
static int state_index;
static debounce_status deb_status[MAX_DEBOUNCE_ITEMS];

bool was_completed;
bool was_on; // Previous state of pgm_running
int distance;
bool was_error; // Previous pass was in error state.

/* Debounce the needed input pins. Debounce is done by adding elapsed time to
 * an accumulator while the bit is TRUE and subtracting elapsed time while the
 * bit is FALSE. The accumulator is limited between 0 and debounce_period. If
 * the accumulator reaches debounce_period, the bit is deemed TRUE. If it
 * reaches 0, the bit is deemed FALSE. */
inline bool debounce(bool input_pin, int index,float period) {
	if(input_pin) { // Input is high
		if(deb_status[index].accum < debounce_period) 
			deb_status[index].accum += period;
		else
			deb_status[index].state = TRUE;
			
	} else { // Input is low
		if(deb_status[index].accum > 0.0)
			deb_status[index].accum -= fperiod;
		else
			deb_status[index].state = FALSE;
	}
	return deb_status[index].state;
}

/* The state LIFO stack array works from index 0 up. The bottom state is always
 *  STATE_IDLE. */
inline void enqueue_state(int state) {
	/* Pushes a new state on our stack. If the stack is full, does nothing */
	if(state_index < (STATE_STACK_DEPTH - 1))
		state_stack[++state_index] = state;
}

inline int dequeue_state(void) {
	/* Pops the next state from the state stack. the bottom state is 
	 *  always STATE_IDLE.
	 */
	if(state_index > 0)
		return state_stack[state_index--];
	else
		return STATE_IDLE;
}

FUNCTION(_) {
	/* Maintain the timer. Used for hardware timouts */
	timer += fperiod;	

	was_completed = completed; // save previous value
	completed = debounce(qd_complete,DEBOUNCE_QD_COMPLETE,fperiod);
	claw_open_deb = debounce(claw_open,DEBOUNCE_QD_JAW_OPEN,fperiod);
	/* Unhome the tool changer if the Quickdraw hardware has been switched from AUTO mode */
	if(!debounce(qd_auto,DEBOUNCE_QD_AUTO,fperiod))
		homed_flag = FALSE;

	/* Maintain the past and current machine states. */
	was_on = is_on;
	is_on = machine_on;
			
	state_changed = (cur_state != prev_state);
	was_error = (prev_state == STATE_ERROR);
	if(state_changed) {
		prev_state = cur_state;
	} 

	/* If the machine is off, don't do anything. Turn off all the outputs and stay in the error state. */
	if(!is_on) {
		cur_state = STATE_ERROR;
		tool_in_output = FALSE;
		tool_out_output = FALSE;
		carousel_cw_output = FALSE;
		carousel_ccw_output = FALSE;
		carousel_home_output = FALSE;
	}

	/* On entering each state other than IDLE, check for AUTO mode. If not, it's an error. */
	switch(cur_state) {
		case STATE_IDLE: // Check toolchange_req for a new tool request.
			if(state_changed) {
				/* Since cur_state is initialized to STATE_IDLE and at startup there is no state change, 
				 *  we must have come here from another state. If it wasn't the STATE_ERROR, set done TRUE */
				if(!was_error)
					done = TRUE;
			} else if(toolchange_req && !done) {
				/* Latch the new tool inputs. */
				new_tool_in = new_tool_no;
				if(new_tool_in < 0 || new_tool_in > changer_capacity) {
					rtapi_print_msg(RTAPI_MSG_ERR, "Invalid new_tool_no passed to qdtoolchange");
					error_outputs = ERROR_INVALID_NEW_TOOL;
					cur_state = STATE_ERROR;
				} else {
					/* All OK. Continue */
					cur_state = STATE_INIT;
				}
			} else if(!toolchange_req && done) {
				/* Release the ack only when the toolchange_req goes FALSE. */
				done = FALSE;
			}
			break; // STATE_IDLE

		case STATE_INIT:
			/* Check state of hardware and take action if needed. Otherwise, start the tool change.
			 * If not homed, we need to do that first. */
			if(!qd_auto) {
				 rtapi_print_msg(RTAPI_MSG_ERR, "Tool Changer not Switched to AUTO Mode");
				 error_outputs = ERROR_NOT_AUTO_MODE;
				 cur_state = STATE_ERROR;
			} else if(completed) {
				/* completed is TRUE. We must wait for it to go FALSE before initiating a movement. */
				enqueue_state(STATE_INIT);
				cur_state = STATE_WAIT_COMPL_FALSE;
			} else if(!claw_open_deb) {
				/* The claw-open signal is not present. We can't proceed without that. Probably no
				 *  air line connected. */
				rtapi_print_msg(RTAPI_MSG_ERR, "Tool Changer not Reporting Claw Open. Check Compressed Air");
				error_outputs = ERROR_NOT_CLAW_OPEN;
				cur_state = STATE_ERROR;
			} else {
				if(new_tool_in) {
					/* Only put a new tool in if asked to. Zero for new_tool_in means just 
					 *  take the old tool out. */
					enqueue_state(STATE_TOOL_IN);
					enqueue_state(STATE_CAROUSEL_MOVE);
				}
				if(homed_flag) {
					/* We assume if we're homed the carousel is already in position. So 
					 *  just take the tool out. */
					cur_state = STATE_TOOL_OUT;
				} else {
					/* Not homed. Take the tool out and home it. */
					enqueue_state(STATE_CAROUSEL_HOME);
					cur_state = STATE_TOOL_OUT;
				}
			}
			break; // STATE_INIT

		case STATE_TOOL_OUT: // Move the arm from spindle to carousel.
			if(!qd_auto) {
				 rtapi_print_msg(RTAPI_MSG_ERR, "Tool Changer not Switched to AUTO Mode");
				 error_outputs = ERROR_NOT_AUTO_MODE;
				 cur_state = STATE_ERROR;
			} else if(state_changed) {
				if(completed) {
					/* Wait for completed to go FALSE */
					enqueue_state(cur_state);
					cur_state = STATE_WAIT_COMPL_FALSE;
				} else {
					timer = 0.0;
					tool_out_output = TRUE;
				}
			} else {
				if(completed) {
					/* Done! */
					tool_out_output = FALSE;
					cur_state = dequeue_state();
				} else if(timer >= arm_move_timeout) {
					tool_out_output = FALSE;
					rtapi_print_msg(RTAPI_MSG_ERR, "Quickdraw Took Too Long to Move the Arm to the Carousel");
					error_outputs = ERROR_ARM_TO_CAROUSEL_FAIL;
					cur_state = STATE_ERROR;
				}
			}
			break; // STATE_TOOL_OUT

		case STATE_TOOL_IN: // Move the arm from spindle to carousel.
			if(!qd_auto) {
				 rtapi_print_msg(RTAPI_MSG_ERR, "Tool Changer not Switched to AUTO Mode");
				 error_outputs = ERROR_NOT_AUTO_MODE;
				 cur_state = STATE_ERROR;
			} else if(state_changed) {
				if(completed) {
					/* Wait for completed to go FALSE */
					enqueue_state(cur_state);
					cur_state = STATE_WAIT_COMPL_FALSE;
				} else {
					timer = 0.0;
					tool_in_output = TRUE;
				}
			} else {
				if(completed) {
					/* Done with the tool change. */
					tool_in_output = FALSE;
					cur_state = dequeue_state();
				} else if(timer >= arm_move_timeout) {
					tool_in_output = FALSE;
					rtapi_print_msg(RTAPI_MSG_ERR, "Quickdraw Took Too Long to Move the Arm to the Spindle");
					error_outputs = ERROR_ARM_TO_SPINDLE_FAIL;
					cur_state = STATE_ERROR;
				}
			}
			break; // STATE_TOOL_IN
	
		case STATE_CAROUSEL_MOVE: // Move to new tool position
			if(!qd_auto) {
				 rtapi_print_msg(RTAPI_MSG_ERR, "Tool Changer not Switched to AUTO Mode");
				 error_outputs = ERROR_NOT_AUTO_MODE;
				 cur_state = STATE_ERROR;
			} else if (state_changed) {
				if(completed) {
					/* Wait for completed to go FALSE */
					enqueue_state(cur_state);
					cur_state = STATE_WAIT_COMPL_FALSE;
				} else {
					/*  Start the timer, determine which way and how far to move the carousel, and start the movement. */
					timer = 0.0;
					if(!new_tool_in || (new_tool_in == cur_pocket_no)) {
						/* No move necessary. */
						cur_state = dequeue_state();
					} else {
						distance = new_tool_in - cur_pocket_no;
						move_cw = ((distance + changer_capacity) % changer_capacity) > (changer_capacity / 2);
						if(move_cw)
							carousel_cw_output = TRUE;
						else
							carousel_ccw_output = TRUE;
					}
				}
			} else if(!completed && was_completed) {
				/* The debounced completed input has just gone FALSE. Reset the timer */
				timer = 0.0;
			} else if(completed && was_completed) {
				/* Completed is high and was high in the previous cycle. Wait for it to go FALSE, 
				 *  but not past the timeout. We don't use the STATE_WAIT_COMPL_FALSE state since it might
				 *  require a two-level return stack. */
				if(timer >= complete_max_time) {
					rtapi_print_msg(RTAPI_MSG_ERR, "qd-complete input (Quickdraw RESET output) set for too long");
					error_outputs = ERROR_QD_COMPLETE_STUCK_HIGH;
					cur_state = STATE_ERROR;
				}
			} else if(completed && !was_completed) {
				/* completed has just gone TRUE. We've moved one tool. Reset the timer,
				 *  update the pocket number, and check if we've gone around the end. */
				timer = 0.0;
				if(move_cw) {
					// CW movement. Decreasing pocket numbers
					if(--cur_pocket_no < 1)
						cur_pocket_no = changer_capacity;
				} else {
					// CCW movement. Increasing pocket numbers
					if(++cur_pocket_no > changer_capacity)
						cur_pocket_no = 1;
				}
				if(cur_pocket_no == new_tool_in) {
					/* We're done. Turn both directions off to be sure */
					carousel_cw_output = FALSE;
					carousel_ccw_output = FALSE;
					cur_state = dequeue_state();
				}
			} else if(!completed && (timer >= carousel_move_timeout)) {
				/* completed is still false and has timed out */
				carousel_cw_output = FALSE;
				carousel_ccw_output = FALSE;
				rtapi_print_msg(RTAPI_MSG_ERR, "Quickdraw took too long to move the carousel");
				error_outputs = ERROR_CAROUSEL_MOVE_FAIL;
				cur_state = STATE_ERROR;
			}
			break; // STATE_CAROUSEL_MOVE

		case STATE_CAROUSEL_HOME:
			if(!qd_auto) {
				 rtapi_print_msg(RTAPI_MSG_ERR, "Tool Changer not Switched to AUTO Mode");
				 error_outputs = ERROR_NOT_AUTO_MODE;
				 cur_state = STATE_ERROR;
			} else if(state_changed) {
				if(completed) {
					/* Wait for completed to go FALSE */
					enqueue_state(cur_state);
					cur_state = STATE_WAIT_COMPL_FALSE;
				} else {
					timer = 0.0;
					carousel_home_output = TRUE;
				}
			} else if(completed) {
				/* Done with homing the carousel. */
				carousel_home_output = FALSE;
				homed_flag = TRUE;
				cur_pocket_no = 1;
				cur_state = dequeue_state();
			} else if(timer >= carousel_home_timeout) {
				carousel_home_output = FALSE;
				rtapi_print_msg(RTAPI_MSG_ERR, "Quickdraw took too long to home the carousel");
				error_outputs = ERROR_CAROUSEL_HOME_FAIL;
				cur_state = STATE_ERROR;
			}
			break; // STATE_CAROUSEL_HOME
		
		case STATE_WAIT_COMPL_FALSE:
			if(!qd_auto) {
				 rtapi_print_msg(RTAPI_MSG_ERR, "Tool Changer not Switched to AUTO Mode");
				 error_outputs = ERROR_NOT_AUTO_MODE;
				 cur_state = STATE_ERROR;
			} else if(state_changed) {
				// Initialize the timer on entering this state
				timer = 0.0;
			} else if(completed) {
				/* The debounced version of qd_complete is still TRUE. We need to wait for this to go
				 *  FALSE before going to the next_state. */
				if(timer >= complete_max_time) {
					rtapi_print_msg(RTAPI_MSG_ERR, "qd-complete input (Quickdraw RESET output) set for too long");
					error_outputs = ERROR_QD_COMPLETE_STUCK_HIGH;
					cur_state = STATE_ERROR;
				}
			} else {
				/* OK to move on. */
				cur_state = dequeue_state();
			}
			break; // STATE_WAIT_COMPL_FALSE

		case STATE_ERROR:
			/* Do nothing, but recover when the machine gets turned on. */
			if(!was_on && is_on)
				// We always go back to the idle state, but need to clear the stack
				state_index = 0;
				cur_state = STATE_IDLE;
				error_outputs = 0;
			break; // STATE_ERROR
	}
	current_state = cur_state;
	current_tool = cur_pocket_no;
	error_mask = error_outputs;
	change_ack = (done && claw_open_deb);
	is_homed = homed_flag;
}

EXTRA_SETUP() {
	state_stack[0] = STATE_IDLE;
	prev_state = cur_state = STATE_IDLE;
	return 0;
}
