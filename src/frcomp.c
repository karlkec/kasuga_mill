/* Autogenerated by /usr/bin/comp on Wed Jun  1 09:02:09 2011 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(emc2, "component:frcomp:EMC2 HAL function providing friction compensation");
MODULE_INFO(emc2, "pin:in:float:0:in:The input. Usually connected to a pid output:None:None");
MODULE_INFO(emc2, "pin:out:float:0:out:The output. Usually fed to a pwm or other drive component:None:None");
MODULE_INFO(emc2, "param:mech_friction_pos:float:0:r:The output required to overcome friction in the positive direction:None:None");
MODULE_INFO(emc2, "param:mech_friction_neg:float:0:r:The output required to overcome friction in the negative direction:None:None");
MODULE_INFO(emc2, "param:motion_tol_pos:float:0:r:The amount of motion command tolerated before motion starts in the positive direction:None:None");
MODULE_INFO(emc2, "param:motion_tol_neg:float:0:r:The amount of motion command tolerated before motion starts in the negative direction:None:None");
MODULE_INFO(emc2, "funct:_:1:");
MODULE_INFO(emc2, "descr:\nProvides friction compensation. Intended to be inserted between the pid output and a pwm or other drive component\nin a servo system. This component compensates for lack of motion seen by many servo systems with small\ntorque or velocity commands. It tries to overcome friction by providing a higher gain for small-magnitude movements.\n\nThis function provides a transfer function which has a high-gain portion when in between motion_tol_neg and motion_tol_pos, and\ngain of 1 outside this range. The output is continuous and monotonic provided motion_tol_pos is greater than \nmotion_tol_neg, and mech_friction_pos is greater than mech_friction_neg.\n\nUsually motion_tol_pos and motion_tol_neg should be symmetrical around zero. Use caution with small differences between \nmotion_tol_pos and motion_tol_neg, as this can result in high gain around zero which can affect pid loop stability.\nOften a ratio of 5:1 or less is sufficient for the mech_friction range divided by the motion_tol range.");
MODULE_INFO(emc2, "license:GPL");
MODULE_INFO(emc2, "author:K. Cunningham");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct state {
    struct state *_next;
    hal_float_t *in;
    hal_float_t *out;
    hal_float_t mech_friction_pos;
    hal_float_t mech_friction_neg;
    hal_float_t motion_tol_pos;
    hal_float_t motion_tol_neg;
};
struct state *inst=0;
struct state *first_inst=0, *last_inst=0;

static void _(struct state *inst, long period);
static int get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 2];
    int r = 0;
    int sz = sizeof(struct state) + get_data_size();
    struct state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    r = hal_pin_float_newf(HAL_IN, &(inst->in), comp_id,
        "%s.in", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->out), comp_id,
        "%s.out", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RO, &(inst->mech_friction_pos), comp_id,
        "%s.mech-friction-pos", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RO, &(inst->mech_friction_neg), comp_id,
        "%s.mech-friction-neg", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RO, &(inst->motion_tol_pos), comp_id,
        "%s.motion-tol-pos", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RO, &(inst->motion_tol_neg), comp_id,
        "%s.motion-tol-neg", prefix);
    if(r != 0) return r;
    rtapi_snprintf(buf, HAL_NAME_LEN, "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(last_inst) last_inst->_next = inst;
    last_inst = inst;
    if(!first_inst) first_inst = inst;
    return 0;
}
static int default_count=1, count=0;
char *names[16] = {0,};
RTAPI_MP_INT(count, "number of frcomp");
RTAPI_MP_ARRAY_STRING(names, 16, "names of frcomp");
int rtapi_app_main(void) {
    int r = 0;
    int i;
    comp_id = hal_init("frcomp");
    if(comp_id < 0) return comp_id;
    if(count && names[0]) {
        rtapi_print_msg(RTAPI_MSG_ERR,"count= and names= are mutually exclusive\n");
        return -EINVAL;
    }
    if(!count && !names[0]) count = default_count;
    if(count) {
        for(i=0; i<count; i++) {
            char buf[HAL_NAME_LEN + 2];
            rtapi_snprintf(buf, HAL_NAME_LEN, "frcomp.%d", i);
        r = export(buf, i);
            if(r != 0) break;
       }
    } else {
        for(i=0; names[i]; i++) {
        r = export(names[i], i);
            if(r != 0) break;
       }
    }
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct state *inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct state *inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef in
#define in (0+*inst->in)
#undef out
#define out (*inst->out)
#undef mech_friction_pos
#define mech_friction_pos (inst->mech_friction_pos)
#undef mech_friction_neg
#define mech_friction_neg (inst->mech_friction_neg)
#undef motion_tol_pos
#define motion_tol_pos (inst->motion_tol_pos)
#undef motion_tol_neg
#define motion_tol_neg (inst->motion_tol_neg)


FUNCTION(_) {
#line 25 "frcomp.comp"
if(motion_tol_pos == motion_tol_neg)
	out = in;
else {
	if (in > motion_tol_pos)
		out = in + mech_friction_pos - motion_tol_pos;
	else if (in < motion_tol_neg)
		out = in + mech_friction_neg - motion_tol_neg;
	else
		out = (in - motion_tol_neg) * (mech_friction_neg - mech_friction_pos) / (motion_tol_pos - motion_tol_neg) + mech_friction_neg;
}	
	
}

static int get_data_size(void) { return 0; }
